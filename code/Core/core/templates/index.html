<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    {% load static %}
    <link rel="stylesheet" href="{% static 'style.css' %}"/>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <title>SOK Tim3</title>
</head>
<body>
<div class="wrapper">
    <nav class="border-frame">
        <div class="logo">
            <h1>Team3 Graph Visualizator</h1>
        </div>

        <div class="selections">
            <form id="parameters-form">
                {% csrf_token %}
                <div class="selections-row">
                    <select id="visualizator-selection" name="visualization">
                        <option value="default">select visualizator</option>
                        {% for visualizator in visualizators %}
                            <option value="{{ visualizator.name }}">{{ visualizator.name }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="selections-row">
                    <h2>parse and visualize graph from file:</h2>
                    <select id="parser-selection" name="parser">
                        <option value="default">select parser</option>
                        {% for parser in parsers %}
                            <option value="{{ parser.name }}">{{ parser.name }}</option>
                        {% endfor %}
                    </select>
                    <input type="file" id="file-selection" name="file">
                    <button id="parse-file-button" type="button">Parse file</button>
                </div>
                <div class="selections-row">
                    <h2>load existing graph:</h2>
                    <select id="graph-selection" name="graph">
                        <option value="default">select graph</option>
                        {% for graph in loaded_graphs %}
                            <option value="{{ graph.name }}">{{ graph.name }}</option>
                        {% endfor %}
                    </select>
                    <button id="load-graph-button" type="button">Load graph</button>
                </div>
            </form>
        </div>
    </nav>

    <div class="upper">
        <div class="tree-view border-frame">
            <svg id="tree-svg" width="100%" height="100%"></svg>
        </div>

        <div class="main-visual border-frame" id="main-div">
            {% if rendered_graph %}
                {{ rendered_graph|safe }}
            {% endif %}
        </div>
    </div>

    <div class="lower">
        <div class="bird-view border-frame">
            <svg id="bird-svg"></svg>
        </div>

        <div class="search-and-details border-frame">
                <div class="search-and-details-inner">
                    <h2>Search and filter</h2>
                    <div class="search">
                     <form>
                        <input type="text" id="search-filter-input" name="search-filter-text" value="{{ search_filter_current_text }}">

                        <div id="buttons-div">
                            <input type="submit" class="sf-button" id="filter-button" value="Filter">
                            <input type="submit" class="sf-button" id="search-button" value="Search">
                        </div>
                    </form>
            </div>

                </div>
            <div class="details">
                <p class="node-details"></p>
            </div>
        </div>
    </div>
</div>

<script>
    // Get the CSRF token from the cookie
    function getCookie(name) {
        const cookieValue = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
        return cookieValue ? cookieValue.pop() : '';
    }

    const csrftoken = getCookie('csrftoken');

    // Add event listeners to the buttons
    const parseButton = document.getElementById('parse-file-button');
    parseButton.addEventListener('click', () => {
        event.preventDefault();
        // Get the selected values
        const visualizatorSelection = document.getElementById('visualizator-selection').value;
        const parserSelection = document.getElementById('parser-selection').value;
        const fileSelection = document.getElementById('file-selection').files[0]; // Assuming you want to upload a single file

        // Check if a visualizer is selected
        if (visualizatorSelection === 'default') {
            alert('Please select a visualizer before parsing the file.');
            return;
        }

        // Check if a parser is selected
        if (parserSelection === 'default') {
            alert('Please select a parser before parsing the file.');
            return;
        }

        // Create a FormData object to send the data
        const formData = new FormData();
        formData.append('visualization', visualizatorSelection);
        formData.append('parser', parserSelection);
        formData.append('file', fileSelection);

        // Send a POST request to the desired URL
        fetch('/parse_and_visualize', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrftoken,
            },
            body: formData,
        })
            .then(response => {
                // Handle the response as needed
                window.location.href = '/parse_and_visualize';
                console.log(response);
            })
            .catch(error => {
                // Handle any errors
                console.error(error);
            });
    });

    const loadButton = document.getElementById('load-graph-button');
    loadButton.addEventListener('click', () => {
        event.preventDefault();
        // Get the selected values
        const visualizatorSelection = document.getElementById('visualizator-selection').value;
        const graphSelection = document.getElementById('graph-selection').value;

        // Check if a visualizer is selected
        if (visualizatorSelection === 'default') {
            alert('Please select a visualizer before loading the graph.');
            return;
        }

        // Check if a graph is selected
        if (graphSelection === 'default') {
            alert('Please select a graph before loading.');
            return;
        }

        // Create a FormData object to send the data
        const formData = new FormData();
        formData.append('visualization', visualizatorSelection);
        formData.append('graph', graphSelection);

        // Send a POST request to the desired URL
        fetch('/load_and_visualize', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrftoken,
            },
            body: formData,
        })
            .then(response => {
                // Handle the response as needed
                window.location.href = '/load_and_visualize';
                console.log(response);
            })
            .catch(error => {
                // Handle any errors
                console.error(error);
            });
    });

</script>


<script>

    const searchButton = document.getElementById('search-button');
    searchButton.addEventListener('click', () => {
        event.preventDefault();
        // Get the search filter text
        const searchFilterText = document.getElementById('search-filter-input').value;

        // Check if the search filter text is empty
        if (searchFilterText.trim() === '') {
            alert('Please enter a search filter text.');
            return;
        }

        // Redirect to the search URL with the search filter text as a parameter
        window.location.href = `/search/${encodeURIComponent(searchFilterText)}`;
    });

</script>

<script>
    const filterButton = document.getElementById('filter-button');
    filterButton.addEventListener('click', () => {
        event.preventDefault();
        // Get the filter text
        const filterText = document.getElementById('search-filter-input').value;

        // Check if the filter text is empty
        if (filterText.trim() === '') {
            alert('Please enter a filter text.');
            return;
        }

        // Redirect to the filter URL with the filter text as a parameter
        window.location.href = `/filter/${encodeURIComponent(filterText)}`;
    });
</script>


<script>
  // Call the copyGraphToBirdView function when the simulation ends
simulation.on('end', () => {
  copyGraphToBirdView();
});

// Function to copy the contents of the SVG graph to the bird view
function copyGraphToBirdView() {
  const visualizationSvg = document.getElementById('visualization').querySelector('svg');
  const birdViewSvg = document.getElementById('bird-svg');
  const birdViewContainer = document.querySelector('.bird-view.border-frame');
  const overlay = document.createElement('div');
  overlay.classList.add('overlay');
  overlay.textContent = 'Waiting for graph...';

  // Add the overlay to the bird view container
  birdViewContainer.appendChild(overlay);

  // Clear any existing content in the bird view SVG
  birdViewSvg.innerHTML = '';

  // Clone the visualization SVG's g tag and insert it into the bird view SVG
  const clonedG = visualizationSvg.querySelector('g').cloneNode(true);
  birdViewSvg.appendChild(clonedG);

  // Set the bird view SVG size to match the container size
  const birdViewWidth = birdViewContainer.clientWidth;
  const birdViewHeight = birdViewContainer.clientHeight;
  birdViewSvg.setAttribute('width', birdViewWidth);
  birdViewSvg.setAttribute('height', birdViewHeight);

  // Get the dimensions of the cloned g tag
  const clonedGBox = clonedG.getBBox();
  const clonedGWidth = clonedGBox.width;
  const clonedGHeight = clonedGBox.height;

  // Calculate the scaling factors to fit the g tag within the bird view SVG
  const scaleX = (birdViewWidth * 0.9) / clonedGWidth;
  const scaleY = (birdViewHeight * 0.9) / clonedGHeight;
  const scale = Math.min(scaleX, scaleY);

  // Apply the scaling to the g tag
  const translateX = (birdViewWidth - clonedGWidth * scale) / 2 - clonedGBox.x * scale;
  const translateY = (birdViewHeight - clonedGHeight * scale) / 2 - clonedGBox.y * scale;
  clonedG.setAttribute('transform', `translate(${translateX},${translateY}) scale(${scale})`);

  // Remove the overlay once the bird view is ready
  birdViewContainer.removeChild(overlay);
}

</script>

<script>
  // TREE VIEW GENERATION

  var treeWidth = "100%";
  var treeHeight = 400;
  var treeNodeRadius = 10;
  var treeColumnSpacing = 10;

  var treeSvg = d3
    .select("#tree-svg")
    .append("svg")
    .attr("width", treeWidth)
    .attr("height", treeHeight)
    .call(d3.zoom().on("zoom", treeZoomed))
    .append("g");

  var treeRootNode = nodes[0];
  var treeVisitedNodes = new Set();
  var treeMaxDepth = 0; // Track the maximum depth reached
  var treeColumnWidth = (parseInt(treeWidth) - treeColumnSpacing) / getMaxDepth(treeRootNode); // Calculate the column width dynamically

  function generateTreeView(node, x, y, depth, parent) {
    if (treeVisitedNodes.has(node.id)) {
      return;
    }

    treeVisitedNodes.add(node.id);

    var treeNodeGroup = treeSvg.append("g").attr("class", "tree-node-group");

    treeNodeGroup
      .append("circle")
      .attr("cx", x)
      .attr("cy", y)
      .attr("r", treeNodeRadius)
      .style("fill", "#5DADE2");

    treeNodeGroup
      .append("text")
      .attr("x", x + treeNodeRadius * 1.5)
      .attr("y", y)
      .attr("text-anchor", "start")
      .attr("fill", "black")
      .attr("font-size", "12px")
      .text(node.name);

    treeNodeGroup.on("click", function (event) {
      if (event.defaultPrevented || event.ctrlKey) return;

      if (node.expanded) {
        treeCollapseNode(node, treeNodeGroup);
      } else {
        treeExpandNode(node, x, y, depth + 1);
      }

      event.stopPropagation(); // Prevent event bubbling
    });

    if (node.expanded) {
      var treeChildNodes = getTreeChildNodes(node);
      var treeNumChildNodes = treeChildNodes.length;

      if (treeNumChildNodes > 0 && !treeVisitedNodes.has(treeChildNodes[0].id)) {
        var nextX = x + treeColumnWidth + treeColumnSpacing;
        var nextY = y - ((treeNumChildNodes - 1) * (treeNodeRadius * 2 + treeColumnSpacing)) / 2;

        for (var i = 0; i < treeNumChildNodes; i++) {
          var treeChildNode = treeChildNodes[i];
          generateTreeView(treeChildNode, nextX, nextY, depth + 1, node);
          nextY += treeNodeRadius * 2 + treeColumnSpacing;
        }

        // Update the treeMaxDepth if the current depth is greater
        treeMaxDepth = Math.max(treeMaxDepth, depth + 1);
      }
    }
  }

  function getTreeChildNodes(node) {
    var treeChildNodes = [];

    for (var i = 0; i < nodes.length; i++) {
      if (edgeMatrix[nodes.indexOf(node)][i]) {
        treeChildNodes.push(nodes[i]);
      }
    }

    return treeChildNodes;
  }

  function treeCollapseNode(node, group) {
  node.expanded = false;

  // Recursively collapse the descendant nodes
  group.selectAll(".tree-node-group").each(function (d) {
    if (isTreeDescendantOf(d, node)) {
      treeCollapseNode(d, d3.select(this));
    }
  });

  // Remove the descendant nodes from the DOM
  group.selectAll(".tree-node-group").remove();
}


  function treeExpandNode(node, x, y, depth) {
    node.expanded = true;

    var treeChildNodes = getTreeChildNodes(node);
    var treeNumChildNodes = treeChildNodes.length;

    if (treeNumChildNodes > 0) {
      var nextX = x + treeColumnWidth + treeColumnSpacing;
      var nextY = y - ((treeNumChildNodes - 1) * (treeNodeRadius * 2 + treeColumnSpacing)) / 2;

      for (var i = 0; i < treeNumChildNodes; i++) {
        var treeChildNode = treeChildNodes[i];

        if (!treeVisitedNodes.has(treeChildNode.id)) {
          generateTreeView(treeChildNode, nextX, nextY, depth + 1, node);
          treeVisitedNodes.add(treeChildNode.id);
          nextY += treeNodeRadius * 2 + treeColumnSpacing;
        }
      }

      // Update the treeMaxDepth if the current depth is greater
      treeMaxDepth = Math.max(treeMaxDepth, depth + 1);
    }
  }

  function isTreeDescendantOf(node, ancestor) {
    if (node === ancestor) {
      return true;
    }

    var parentNode = node.parent;

    while (parentNode !== null) {
      if (parentNode === ancestor) {
        return true;
      }
      parentNode = parentNode.parent;
    }

    return false;
  }

  function treeZoomed(event) {
    treeSvg.attr("transform", `translate(${event.transform.x}, 0) scale(${event.transform.k}, 1)`);
  }

  generateTreeView(treeRootNode, parseInt(treeWidth) / 2, treeHeight / 2, 0, null);

  // Adjust the width of the SVG based on the treeMaxDepth reached
  var treeSvgWidth = (treeColumnWidth + treeColumnSpacing) * treeMaxDepth + treeColumnSpacing;
  treeSvg.attr("width", treeSvgWidth);

  function getMaxDepth(node) {
    if (node.expanded) {
      var childNodes = getTreeChildNodes(node);
      var maxChildDepth = 0;

      for (var i = 0; i < childNodes.length; i++) {
        var childDepth = getMaxDepth(childNodes[i]);
        maxChildDepth = Math.max(maxChildDepth, childDepth);
      }

      return maxChildDepth + 1;
    }

    return 1;
  }
</script>





</div>
</body>
</html>
