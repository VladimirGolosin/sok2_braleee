<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    {% load static %}
    <link rel="stylesheet" href="{% static 'style.css' %}"/>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <title>SOK Tim3</title>
</head>
<body>
<div class="wrapper">
    <nav class="border-frame">
        <div class="logo">
            <h1>Team3 Graph Visualizator</h1>
        </div>

        <div class="selections">
            <form id="parameters-form">
                {% csrf_token %}
                <div class="selections-row">
                    <select id="visualizator-selection" name="visualization">
                        <option value="default">select visualizator</option>
                        {% for visualizator in visualizators %}
                            <option value="{{ visualizator.name }}">{{ visualizator.name }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="selections-row">
                    <h2>parse and visualize graph from file:</h2>
                    <select id="parser-selection" name="parser">
                        <option value="default">select parser</option>
                        {% for parser in parsers %}
                            <option value="{{ parser.name }}">{{ parser.name }}</option>
                        {% endfor %}
                    </select>
                    <input type="file" id="file-selection" name="file">
                    <button id="parse-file-button" type="button">Parse file</button>
                </div>
                <div class="selections-row">
                    <h2>load existing graph:</h2>
                    <select id="graph-selection" name="graph">
                        <option value="default">select graph</option>
                        {% for graph in loaded_graphs %}
                            <option value="{{ graph.name }}">{{ graph.name }}</option>
                        {% endfor %}
                    </select>
                    <button id="load-graph-button" type="button">Load graph</button>
                </div>
            </form>
        </div>
    </nav>

    <div class="upper">
        <div class="tree-view border-frame">
            <svg id="tree-svg" width="100%" height="100%"></svg>
        </div>

        <div class="main-visual border-frame" id="main-div">
            {% if rendered_graph %}
                {{ rendered_graph|safe }}
            {% endif %}
        </div>
    </div>

    <div class="lower">
        <div class="bird-view border-frame">
            <svg id="bird-svg"></svg>
        </div>

        <div class="search-and-details border-frame">
                <div class="search-and-details-inner">
                    <h2>Search and filter</h2>
                    <div class="search">
                     <form>
                        <input type="text" id="search-filter-input" name="search-filter-text" value="{{ search_filter_current_text }}">

                        <div id="buttons-div">
                            <input type="submit" class="sf-button" id="filter-button" value="Filter">
                            <input type="submit" class="sf-button" id="search-button" value="Search">
                        </div>
                    </form>
            </div>

                </div>
            <div class="details">
                <p class="node-details"></p>
            </div>
        </div>
    </div>
</div>

<script>
    // Get the CSRF token from the cookie
    function getCookie(name) {
        const cookieValue = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
        return cookieValue ? cookieValue.pop() : '';
    }

    const csrftoken = getCookie('csrftoken');

    // Add event listeners to the buttons
    const parseButton = document.getElementById('parse-file-button');
    parseButton.addEventListener('click', () => {
        event.preventDefault();
        // Get the selected values
        const visualizatorSelection = document.getElementById('visualizator-selection').value;
        const parserSelection = document.getElementById('parser-selection').value;
        const fileSelection = document.getElementById('file-selection').files[0]; // Assuming you want to upload a single file

        // Check if a visualizer is selected
        if (visualizatorSelection === 'default') {
            alert('Please select a visualizer before parsing the file.');
            return;
        }

        // Check if a parser is selected
        if (parserSelection === 'default') {
            alert('Please select a parser before parsing the file.');
            return;
        }

        // Create a FormData object to send the data
        const formData = new FormData();
        formData.append('visualization', visualizatorSelection);
        formData.append('parser', parserSelection);
        formData.append('file', fileSelection);

        // Send a POST request to the desired URL
        fetch('/parse_and_visualize', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrftoken,
            },
            body: formData,
        })
            .then(response => {
                // Handle the response as needed
                window.location.href = '/parse_and_visualize';
                console.log(response);
            })
            .catch(error => {
                // Handle any errors
                console.error(error);
            });
    });

    const loadButton = document.getElementById('load-graph-button');
    loadButton.addEventListener('click', () => {
        event.preventDefault();
        // Get the selected values
        const visualizatorSelection = document.getElementById('visualizator-selection').value;
        const graphSelection = document.getElementById('graph-selection').value;

        // Check if a visualizer is selected
        if (visualizatorSelection === 'default') {
            alert('Please select a visualizer before loading the graph.');
            return;
        }

        // Check if a graph is selected
        if (graphSelection === 'default') {
            alert('Please select a graph before loading.');
            return;
        }

        // Create a FormData object to send the data
        const formData = new FormData();
        formData.append('visualization', visualizatorSelection);
        formData.append('graph', graphSelection);

        // Send a POST request to the desired URL
        fetch('/load_and_visualize', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrftoken,
            },
            body: formData,
        })
            .then(response => {
                // Handle the response as needed
                window.location.href = '/load_and_visualize';
                console.log(response);
            })
            .catch(error => {
                // Handle any errors
                console.error(error);
            });
    });

</script>


<script>

    const searchButton = document.getElementById('search-button');
    searchButton.addEventListener('click', () => {
        event.preventDefault();
        // Get the search filter text
        const searchFilterText = document.getElementById('search-filter-input').value;

        // Check if the search filter text is empty
        if (searchFilterText.trim() === '') {
            alert('Please enter a search filter text.');
            return;
        }

        // Redirect to the search URL with the search filter text as a parameter
        window.location.href = `/search/${encodeURIComponent(searchFilterText)}`;
    });

</script>

<script>
    const filterButton = document.getElementById('filter-button');
    filterButton.addEventListener('click', () => {
        event.preventDefault();
        // Get the filter text
        const filterText = document.getElementById('search-filter-input').value;

        // Check if the filter text is empty
        if (filterText.trim() === '') {
            alert('Please enter a filter text.');
            return;
        }

        // Redirect to the filter URL with the filter text as a parameter
        window.location.href = `/filter/${encodeURIComponent(filterText)}`;
    });
</script>


<script>
  // Call the copyGraphToBirdView function when the simulation ends
simulation.on('end', () => {
  copyGraphToBirdView();
});

// Function to copy the contents of the SVG graph to the bird view
function copyGraphToBirdView() {
  const visualizationSvg = document.getElementById('visualization').querySelector('svg');
  const birdViewSvg = document.getElementById('bird-svg');
  const birdViewContainer = document.querySelector('.bird-view.border-frame');
  const overlay = document.createElement('div');
  overlay.classList.add('overlay');
  overlay.textContent = 'Waiting for graph...';

  // Add the overlay to the bird view container
  birdViewContainer.appendChild(overlay);

  // Clear any existing content in the bird view SVG
  birdViewSvg.innerHTML = '';

  // Clone the visualization SVG's g tag and insert it into the bird view SVG
  const clonedG = visualizationSvg.querySelector('g').cloneNode(true);
  birdViewSvg.appendChild(clonedG);

  // Set the bird view SVG size to match the container size
  const birdViewWidth = birdViewContainer.clientWidth;
  const birdViewHeight = birdViewContainer.clientHeight;
  birdViewSvg.setAttribute('width', birdViewWidth);
  birdViewSvg.setAttribute('height', birdViewHeight);

  // Get the dimensions of the cloned g tag
  const clonedGBox = clonedG.getBBox();
  const clonedGWidth = clonedGBox.width;
  const clonedGHeight = clonedGBox.height;

  // Calculate the scaling factors to fit the g tag within the bird view SVG
  const scaleX = (birdViewWidth * 0.9) / clonedGWidth;
  const scaleY = (birdViewHeight * 0.9) / clonedGHeight;
  const scale = Math.min(scaleX, scaleY);

  // Apply the scaling to the g tag
  const translateX = (birdViewWidth - clonedGWidth * scale) / 2 - clonedGBox.x * scale;
  const translateY = (birdViewHeight - clonedGHeight * scale) / 2 - clonedGBox.y * scale;
  clonedG.setAttribute('transform', `translate(${translateX},${translateY}) scale(${scale})`);

  // Remove the overlay once the bird view is ready
  birdViewContainer.removeChild(overlay);
}

</script>
<script>
  var width = "100%";
  var height = 400;
  var nodeRadius = 20;
  var rowSpacing = 100;
  var columnSpacing = 20;

  var svg = d3
    .select("#tree-svg")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .call(d3.zoom().on("zoom", zoomed))
    .append("g");

  var rootNode = nodes[0];
  var visitedNodes = new Set();
  var maxDepth = 0; // Track the maximum depth reached
  var columnWidth = 200; // Define the columnWidth variable

  function generateTreeView(node, x, y, depth, parent) {
    if (visitedNodes.has(node.id)) {
      return;
    }

    visitedNodes.add(node.id);

    var nodeGroup = svg.append("g").attr("class", "node-group");

    nodeGroup
      .append("circle")
      .attr("cx", x)
      .attr("cy", y)
      .attr("r", nodeRadius)
      .style("fill", "#5DADE2");

    nodeGroup
      .append("text")
      .attr("x", x)
      .attr("y", y + nodeRadius * 2)
      .attr("text-anchor", "middle")
      .attr("fill", "black")
      .attr("font-size", "12px")
      .text(node.name);

    nodeGroup.on("click", function (event) {
      if (event.defaultPrevented || event.ctrlKey) return;

      if (node.expanded) {
        collapseNode(node, nodeGroup);
      } else {
        expandNode(node, x, y, depth + 1);
      }
    });

    if (node.expanded) {
      var childNodes = getChildNodes(node);
      var numChildNodes = childNodes.length;

      if (numChildNodes > 0 && !visitedNodes.has(childNodes[0].id)) {
        var nextX = x + (columnWidth + columnSpacing) * (depth + 1);
        var nextY = y - ((numChildNodes - 1) * rowSpacing) / 2;

        for (var i = 0; i < numChildNodes; i++) {
          var childNode = childNodes[i];
          generateTreeView(childNode, nextX, nextY, depth + 1, node);
          nextY += rowSpacing;
        }

        // Update the maxDepth if the current depth is greater
        maxDepth = Math.max(maxDepth, depth + 1);
      }
    }
  }

  function getChildNodes(node) {
    var childNodes = [];

    for (var i = 0; i < nodes.length; i++) {
      if (edgeMatrix[nodes.indexOf(node)][i]) {
        childNodes.push(nodes[i]);
      }
    }

    return childNodes;
  }

  function collapseNode(node, group) {
    node.expanded = false;

    // Remove the descendant nodes from the DOM
    group.selectAll(".node-group").each(function (d) {
      if (isDescendantOf(d, node)) {
        d3.select(this).remove();
      }
    });
  }

  function expandNode(node, x, y, depth) {
    node.expanded = true;

    var childNodes = getChildNodes(node);
    var numChildNodes = childNodes.length;

    if (numChildNodes > 0 && !visitedNodes.has(childNodes[0].id)) {
      var nextX = x + (columnWidth + columnSpacing) * (depth + 1);
      var nextY = y - ((numChildNodes - 1) * rowSpacing) / 2;

      for (var i = 0; i < numChildNodes; i++) {
        var childNode = childNodes[i];
        generateTreeView(childNode, nextX, nextY, depth + 1, node);
        nextY += rowSpacing;
      }

      // Update the maxDepth if the current depth is greater
      maxDepth = Math.max(maxDepth, depth + 1);
    }
  }

  function isDescendantOf(node, ancestor) {
    if (node === ancestor) {
      return true;
    }

    var parentNode = node.parent;

    while (parentNode !== null) {
      if (parentNode === ancestor) {
        return true;
      }
      parentNode = parentNode.parent;
    }

    return false;
  }

  function zoomed(event) {
    svg.attr("transform", `translate(${event.transform.x}, 0) scale(${event.transform.k}, 1)`);
  }

  generateTreeView(rootNode, parseInt(width) / 2, height / 2, 0, null);

  // Adjust the width of the SVG based on the maxDepth reached
  var svgWidth = (columnWidth + columnSpacing) * maxDepth + columnSpacing;
  svg.attr("width", svgWidth);
</script>




</div>
</body>
</html>
