<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    {% load static %}
    <link rel="stylesheet" href="{% static 'style.css' %}"/>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <title>SOK Tim3</title>
</head>
<body>
<div class="wrapper">
    <nav class="border-frame">
        <div class="logo">
            <h1>Team3 Graph Visualizator</h1>
        </div>

        <div class="selections">
            <form id="parameters-form">
                {% csrf_token %}
                <div class="selections-row">
                    <select id="visualizator-selection" name="visualization">
                        <option value="default">select visualizator</option>
                        {% for visualizator in visualizators %}
                            <option value="{{ visualizator.name }}">{{ visualizator.name }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="selections-row">
                    <h2>parse and visualize graph from file:</h2>
                    <select id="parser-selection" name="parser">
                        <option value="default">select parser</option>
                        {% for parser in parsers %}
                            <option value="{{ parser.name }}">{{ parser.name }}</option>
                        {% endfor %}
                    </select>
                    <input type="file" id="file-selection" name="file">
                    <button id="parse-file-button" type="button">Parse file</button>
                </div>
                <div class="selections-row">
                    <h2>load existing graph:</h2>
                    <select id="graph-selection" name="graph">
                        <option value="default">select graph</option>
                        {% for graph in loaded_graphs %}
                            <option value="{{ graph.name }}">{{ graph.name }}</option>
                        {% endfor %}
                    </select>
                    <button id="load-graph-button" type="button">Load graph</button>
                </div>
            </form>
        </div>
    </nav>

    <div class="upper">
        <div class="tree-view border-frame">

        </div>

        <div class="main-visual border-frame" id="main-div">
            {% if rendered_graph %}
                {{ rendered_graph|safe }}
            {% endif %}
        </div>
    </div>

    <div class="lower">
        <div class="bird-view border-frame">
            <svg id="bird-svg"></svg>
        </div>

        <div class="search-and-details border-frame">
                <div class="search-and-details-inner">
                    <h2>Search and filter</h2>
                    <div class="search">
                     <form>
                        <input type="text" id="search-filter-input" name="search-filter-text" value="{{ search_filter_current_text }}">

                        <div id="buttons-div">
                            <input type="submit" class="sf-button" id="filter-button" value="Filter">
                            <input type="submit" class="sf-button" id="search-button" value="Search">
                        </div>
                    </form>
            </div>

                </div>
            <div class="details">
                <p class="node-details"></p>
            </div>
        </div>
    </div>
</div>

<script>
    // Get the CSRF token from the cookie
    function getCookie(name) {
        const cookieValue = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
        return cookieValue ? cookieValue.pop() : '';
    }

    const csrftoken = getCookie('csrftoken');

    // Add event listeners to the buttons
    const parseButton = document.getElementById('parse-file-button');
    parseButton.addEventListener('click', () => {
        event.preventDefault();
        // Get the selected values
        const visualizatorSelection = document.getElementById('visualizator-selection').value;
        const parserSelection = document.getElementById('parser-selection').value;
        const fileSelection = document.getElementById('file-selection').files[0]; // Assuming you want to upload a single file

        // Check if a visualizer is selected
        if (visualizatorSelection === 'default') {
            alert('Please select a visualizer before parsing the file.');
            return;
        }

        // Check if a parser is selected
        if (parserSelection === 'default') {
            alert('Please select a parser before parsing the file.');
            return;
        }

        // Create a FormData object to send the data
        const formData = new FormData();
        formData.append('visualization', visualizatorSelection);
        formData.append('parser', parserSelection);
        formData.append('file', fileSelection);

        // Send a POST request to the desired URL
        fetch('/parse_and_visualize', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrftoken,
            },
            body: formData,
        })
            .then(response => {
                // Handle the response as needed
                window.location.href = '/parse_and_visualize';
                console.log(response);
            })
            .catch(error => {
                // Handle any errors
                console.error(error);
            });
    });

    const loadButton = document.getElementById('load-graph-button');
    loadButton.addEventListener('click', () => {
        event.preventDefault();
        // Get the selected values
        const visualizatorSelection = document.getElementById('visualizator-selection').value;
        const graphSelection = document.getElementById('graph-selection').value;

        // Check if a visualizer is selected
        if (visualizatorSelection === 'default') {
            alert('Please select a visualizer before loading the graph.');
            return;
        }

        // Check if a graph is selected
        if (graphSelection === 'default') {
            alert('Please select a graph before loading.');
            return;
        }

        // Create a FormData object to send the data
        const formData = new FormData();
        formData.append('visualization', visualizatorSelection);
        formData.append('graph', graphSelection);

        // Send a POST request to the desired URL
        fetch('/load_and_visualize', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrftoken,
            },
            body: formData,
        })
            .then(response => {
                // Handle the response as needed
                window.location.href = '/load_and_visualize';
                console.log(response);
            })
            .catch(error => {
                // Handle any errors
                console.error(error);
            });
    });

</script>


<script>

    const searchButton = document.getElementById('search-button');
    searchButton.addEventListener('click', () => {
        event.preventDefault();
        // Get the search filter text
        const searchFilterText = document.getElementById('search-filter-input').value;

        // Check if the search filter text is empty
        if (searchFilterText.trim() === '') {
            alert('Please enter a search filter text.');
            return;
        }

        // Redirect to the search URL with the search filter text as a parameter
        window.location.href = `/search/${encodeURIComponent(searchFilterText)}`;
    });

</script>

<script>
    const filterButton = document.getElementById('filter-button');
    filterButton.addEventListener('click', () => {
        event.preventDefault();
        // Get the filter text
        const filterText = document.getElementById('search-filter-input').value;

        // Check if the filter text is empty
        if (filterText.trim() === '') {
            alert('Please enter a filter text.');
            return;
        }

        // Redirect to the filter URL with the filter text as a parameter
        window.location.href = `/filter/${encodeURIComponent(filterText)}`;
    });
</script>


<script>
  // Call the copyGraphToBirdView function when the simulation ends
simulation.on('end', () => {
  copyGraphToBirdView();
});

// Function to copy the contents of the SVG graph to the bird view
function copyGraphToBirdView() {
  const visualizationSvg = document.getElementById('visualization').querySelector('svg');
  const birdViewSvg = document.getElementById('bird-svg');
  const birdViewContainer = document.querySelector('.bird-view.border-frame');
  const overlay = document.createElement('div');
  overlay.classList.add('overlay');
  overlay.textContent = 'Waiting for graph...';

  // Add the overlay to the bird view container
  birdViewContainer.appendChild(overlay);

  // Clear any existing content in the bird view SVG
  birdViewSvg.innerHTML = '';

  // Clone the visualization SVG's g tag and insert it into the bird view SVG
  const clonedG = visualizationSvg.querySelector('g').cloneNode(true);
  birdViewSvg.appendChild(clonedG);

  // Set the bird view SVG size to match the container size
  const birdViewWidth = birdViewContainer.clientWidth;
  const birdViewHeight = birdViewContainer.clientHeight;
  birdViewSvg.setAttribute('width', birdViewWidth);
  birdViewSvg.setAttribute('height', birdViewHeight);

  // Get the dimensions of the cloned g tag
  const clonedGBox = clonedG.getBBox();
  const clonedGWidth = clonedGBox.width;
  const clonedGHeight = clonedGBox.height;

  // Calculate the scaling factors to fit the g tag within the bird view SVG
  const scaleX = (birdViewWidth * 0.9) / clonedGWidth;
  const scaleY = (birdViewHeight * 0.9) / clonedGHeight;
  const scale = Math.min(scaleX, scaleY);

  // Apply the scaling to the g tag
  const translateX = (birdViewWidth - clonedGWidth * scale) / 2 - clonedGBox.x * scale;
  const translateY = (birdViewHeight - clonedGHeight * scale) / 2 - clonedGBox.y * scale;
  clonedG.setAttribute('transform', `translate(${translateX},${translateY}) scale(${scale})`);

  // Remove the overlay once the bird view is ready
  birdViewContainer.removeChild(overlay);
}

</script>

<script>
  //TREE VIEW SCRIPT

  const treeDiagonal = d3.linkHorizontal().x(d => d.y).y(d => d.x);

  const rootNode = nodes[0]; // Get the first node from the nodes list
  const treeData = { id: rootNode.id, name: rootNode.name, children: generateTree(0) };

  function generateTree(nodeId, visited = []) {
    const children = [];
    visited.push(nodeId); // Mark the current node as visited

    for (let i = 0; i < nodes.length; i++) {
      if (edgeMatrix[nodeId][i] && !visited.includes(i)) {
        const childNode = { id: nodes[i].id, name: nodes[i].name, children: generateTree(i, visited.slice()) };
        children.push(childNode);
      }
    }

    return children.length ? children : null; // Return null if there are no children
  }

  const treeMargin = { top: 10, right: 120, bottom: 10, left: 40 };
  const treeWidth = 450;
  const treeDx = 10;
  const treeDy = treeWidth / 6;

  const treeLayout = d3.tree().nodeSize([treeDx, treeDy]);

  const treeRoot = d3.hierarchy(treeData, d => d.children); // Specify children accessor

  treeRoot.x0 = treeDy / 2;
  treeRoot.y0 = 0;
  treeRoot.descendants().forEach((d, i) => {
    d.index = i; // Assign an index to each node
    d._children = d.children;
    if (d.data.name !== "aaaa") {
      d.children = null;
    }
  });

  const treeSvg = d3.create("svg")
    .attr("viewBox", [-treeMargin.left, -treeMargin.top, treeWidth, treeDx])
    .style("font", "10px sans-serif")
    .style("user-select", "none");

  const treeGLink = treeSvg.append("g")
    .attr("fill", "none")
    .attr("stroke", "#555")
    .attr("stroke-opacity", 0.4)
    .attr("stroke-width", 1.5);

  const treeGNode = treeSvg.append("g")
    .attr("cursor", "pointer")
    .attr("pointer-events", "all");

  function treeUpdate(source) {
    const duration = d3.event && d3.event.altKey ? 2500 : 250;
    const nodes = treeRoot.descendants().reverse();
    const links = treeRoot.links();

    // Compute the new tree layout.
    treeLayout(treeRoot);

    let left = treeRoot;
    let right = treeRoot;
    treeRoot.eachBefore(node => {
      if (node.x < left.x) left = node;
      if (node.x > right.x) right = node;
    });

    const height = right.x - left.x + treeMargin.top + treeMargin.bottom;

    const transition = treeSvg.transition()
      .duration(duration)
      .attr("viewBox", [-treeMargin.left, left.x - treeMargin.top, treeWidth, height])
      .tween("resize", window.ResizeObserver ? null : () => () => treeSvg.dispatch("toggle"));

    // Update the nodes...
    const node = treeGNode.selectAll("g")
      .data(nodes, d => d.index);

    // Enter any new nodes at the parent's previous position.
    const nodeEnter = node.enter().append("g").attr("class", "tree-node")
      .attr("transform", d => `translate(${source.y0},${source.x0})`)
      .attr("fill-opacity", 0)
      .attr("stroke-opacity", 0)
      .on("click", (event, d) => {
    // Remove the red color from all nodes
    d3.selectAll(".tree-node").attr("fill", d => d._children ? "#555" : "#999");

    // Apply the red color to the clicked node
    d3.select(event.currentTarget).attr("fill", "red");

    d.children = d.children ? null : d._children;
    treeUpdate(d);
  });

    nodeEnter.append("circle")
      .attr("r", 2.5)
      .attr("fill", d => d._children ? "#555" : "#999")
      .attr("stroke-width", 10);

    nodeEnter.append("text")
      .attr("dy", "0.31em")
      .attr("x", d => d._children ? -6 : 6)
      .attr("text-anchor", d => d._children ? "end" : "start")
      .text(d => d.data.name)
      .clone(true).lower()
      .attr("stroke-linejoin", "round")
      .attr("stroke-width", 3)
      .attr("stroke", "white");

    // Transition nodes to their new position.
    const nodeUpdate = node.merge(nodeEnter).transition(transition)
      .attr("transform", d => `translate(${d.y},${d.x})`)
      .attr("fill-opacity", 1)
      .attr("stroke-opacity", 1);

    // Transition exiting nodes to the parent's new position.
    const nodeExit = node.exit().transition(transition).remove()
      .attr("transform", d => `translate(${source.y},${source.x})`)
      .attr("fill-opacity", 0)
      .attr("stroke-opacity", 0);

    // Update the links...
    const link = treeGLink.selectAll("path")
      .data(links, d => d.target.index);

    // Enter any new links at the parent's previous position.
    const linkEnter = link.enter().append("path")
      .attr("d", d => {
        const o = { x: source.x0, y: source.y0 };
        return treeDiagonal({ source: o, target: o });
      });

    // Transition links to their new position.
    link.merge(linkEnter).transition(transition)
      .attr("d", treeDiagonal);

    // Transition exiting nodes to the parent's new position.
    link.exit().transition(transition).remove()
      .attr("d", d => {
        const o = { x: source.x, y: source.y };
        return treeDiagonal({ source: o, target: o });
      });

    // Stash the old positions for transition.
    treeRoot.eachBefore(d => {
      d.x0 = d.x;
      d.y0 = d.y;
    });
  }

  treeUpdate(treeRoot);

  document.querySelector(".tree-view.border-frame").appendChild(treeSvg.node());
</script>



</div>
</body>
</html>